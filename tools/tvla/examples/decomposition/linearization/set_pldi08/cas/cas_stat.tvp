/******************************************************************
* set_stat.tvm
*
* assumptions:
* 1. thread objects can not be referenced by any other object (they are like globals)
* 2. the list is acyclic
*
******************************************************************/

#define IF_IN_SET(var, set) foreach (dummy in { var } & set)
#define CondAssign(cond,pred,result) pred = ((cond) ? (result) : (pred))

%action schedule(loc) {
  %param trnm in Threads
  %t "schedule " + loc
  %f { tr_scheduled(tr) }
  // Free variable is there to case split on there tr goes to
  %p tr_scheduled(tr) & trnm(tr) & at[loc](tr)
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
  %message [trnm(v)] (E(v) !outside(v) & member(v) & (A(w) !bn[n](v,w))) -> "flying member"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
}

%action unschedule(to) {
  %param trnm in Threads
  %t "unschedule. going to " + to
  %p E(tr) tr_scheduled(tr) & trnm(tr) 
  {
    CondAssign(tr_scheduled(v) & trnm(v), at[to](v), 1)
    foreach (loc in locations-{to}) {
      CondAssign(tr_scheduled(v) & trnm(v), at[loc](v), 0)
    } 
    tr_scheduled(tr) = (isthread(tr) ? 1/2 : 0)
  }
  %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
  %message (E(v_1, v_2) member(v_1) & !member(v_2) & !r_by[Tail](v_2) & rv[n](v_1, v_2))-> "member inv"
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
}

//NOTE: We assume that a node can exist only in the concurrent heap and not in
//the sequential heap (and is then marked by dnode) but not vice versa.
/*******************
* assignNew(ref)
* [ref = new T()]
* Allocation to local variable.
* note - the type is currently ignored.
********************/
//ref IS assumed to be null before allocation.

%action assignNew(ref) {
    %param trnm in Threads
    %t ref + "= new T()" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) r_by[ref,trnm](v)) -> "possible assignment to non-null field in new"
    %new
    {
        ref(w, v) = (tr_scheduled(w) ? isNew(v) : ref(w,v))
        r_by[ref,trnm](v) = isNew(v)
        dnode(v) = dnode(v) | isNew(v)

        //new node holds some value val s.t. -inf < val < +inf
        dle(v_1, v_2) =
	       (((isNew(v_1) & isNew(v_2)) |
             (r_by[Head](v_1) & isNew(v_2)) |
             (isNew(v_1) & r_by[Tail](v_2))) ? 1 :
                (((isNew(v_1) & !r_by[Head](v_2) & !isthread(v_2)) |
                  (isNew(v_2) & !r_by[Tail](v_1) & !isthread(v_1))) ? 1/2 :
                 dle(v_1, v_2)))

        eq(v_1, v_2) = 
    	  ((isNew(v_1) | isNew(v_2)) 
        & !r_by[Head](v_1) & !r_by[Tail](v_1) & !isthread(v_1)
        & !r_by[Head](v_2) & !r_by[Tail](v_2) & !isthread(v_2)
        ? 1/2 : eq(v_1, v_2))

        inSOrder[dle,n](v) = inSOrder[dle,n](v) | isNew(v)

        bn[n](o_1,o_2) = bn[n](o_1,o_2) | (isNew(o_1) & isNew(o_2))

        rt[Head](o_1) = rt[Head](o_1)
        rt[Tail](o_1) = rt[Tail](o_1)
        
        //hasMember(v) = (tr_scheduled(v) ? 1/2 : hasMember(v))
	memberEq[x_i,trnm](v) = (member(v) ? 1/2 : 0)
        r_by_tr_sc(v) = r_by_tr_sc(v) | isNew(v)

        //updates due to universe-changing action:

        foreach (fld in NextFields) {
              rv[fld](o_1,o_2) = rv[fld](o_1,o_2)
        }

        foreach (fld in GlobalFields) {
              r_by[fld](o) = r_by[fld](o)
        }

	foreach (fld in BoolLocals) {
        	fld(o) = fld(o) 
	}

        foreach (nm in Threads-{trnm}) {
	     memberEq[x_i,nm](v) = memberEq[x_i,nm](v)
             foreach (fld in LocalFields) {
                r_by[fld,nm](v) = r_by[fld,nm](v)
		     }
        }

        foreach (fld in LocalFields-{ref}) {
            r_by[fld,trnm](v) = r_by[fld,trnm](v)
		}

             michal(t) = michal(t)
             fromFail(t) = fromFail(t)
        foreach (op in Operations) {
             choice[op](t) = choice[op](t)
        }
    }
}

%action Init_New() {
    %param trnm in Threads
    %t "Init_new"
    %f { r_by[x_i,trnm](v1) & eq(v1,v2) } 
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    { }
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
  %message [t2(v)] (E(v) !outside(v) & memberEq[x_i,t2](v) & ! memberEq[x_i,t2](v)) -> "should not be 1/2"
    %decompose
}

// Sequential find:
%action Find_Seq(ref) {
    %param trnm in Threads
    %t "Find_seq(" + ref + ")" + " [" + trnm + "]"
    %f {r_by[ref,trnm](v_1) & dle(v_1,u_1),
        r_by[ref,trnm](v_1) & dle(u_1,v_1)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    {
        res_seq(t_1, o_1) = (tr_scheduled(t_1) ? 
            member(o_1) & (E(o_2) ref(t_1, o_2) & (eq(o_1,o_2) | o_1 == o_2)) : 
            res_seq(t_1, o_1))
        foreach (otrnm in Threads-{trnm}) {
          r_by[res_seq, otrnm](v) = r_by[res_seq, otrnm](v)
        }
    }  
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

//allocating in sequential heap a node that already appears in concurrent heap.
%action assignNew_Seq(ref) {
    %param trnm in Threads
    %t "assignNew_Seq(" + ref + ")" + " [" + trnm + "]"
    %frame_pre |/{
        otrnm(v) <->
       (|/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } |
        |/{ fld(v) : fld in BoolFields } |
         dle(v1,v2) | bn[n](v1,v2))
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> 
        ((trnm(v1) | member(v1) | r_by[ref,trnm](v1)) & (
         &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	 &/{ !at[loc](v1) : loc in locations}))) & otrnm(v2) : otrnm in Threads-{trnm}}
    /*
    %compose trnm(v1) | |/{(trnm(v1) <->
        (trnm(v1) | r_by[ref, trnm](v1)) &  (
	&/{ !at[loc](v1) : loc in locations} &
	&/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	)) & otrnm(v2) : otrnm in Threads-{trnm}}
    */
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in assign new before action"
    {
       dnode(v) = dnode(v) & !(E(w) tr_scheduled(w) & ref(w, v))
    } 
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in assign new"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !rt[Head](v1) & !r_by[Tail](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
     %decompose
}

/***
* assignFromGlbField(ref,fld,trnm)
* ref = fld where ref is a local field and fld is a global field
***/
//ref is not assumed to be null before assignment.
%action assignFromGlbField(ref,fld) {
    %param trnm in Threads
    %t ref + " = " + fld + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) r_by[ref,trnm](v)) -> "possible assignment to non-null field"
    {
        ref(w,v) = (tr_scheduled(w) ? r_by[fld](v) : ref(w,v))
    	foreach (otrnm in Threads-{trnm}) {
        	r_by[ref, otrnm](v) = r_by[ref, otrnm](v)
      	}
    }
    %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %decompose
}

/***
* assignFromNextField(ref,obj,trnm)
* ref = obj.n where ref is a local field and obj is a local field
***/
//ref IS assumed to be null before assignment.
%action assignFromNextField(ref,obj) {
    %param trnm in Threads
    %t ref + " = " + obj + "." + n + " [" + trnm + "]"
    //focus needed becuase we read a successor
    %f { r_by[obj,trnm](v1) & rv[n](v1,v2) & bn[n](v2,v) }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (!(E(v) r_by[obj,trnm](v))) -> "possible null dereference of " + obj + " for " + trnm
    %message [trnm(v)] (E(v) r_by[ref,trnm](v)) -> "possible assignment to non-null field"
    {
       ref(w, o_1) = (tr_scheduled(w) ? E(o_t) obj(w, o_t) & rv[n](o_t,o_1) : ref(w,o_1))
       foreach (otrnm in Threads-{trnm}) {
         r_by[ref, otrnm](v) = r_by[ref, otrnm](v)
       }
    }
    %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %decompose
}

/***
* isDataGreater(ref1,ref2)
* Is the value of the node pointed-to by local variable ref1 greater-or-equal to
* the value of the node pointed-to by local variable ref2.
***/
%action isDataGreater(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data > " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
        |/{ at[loc](v) : loc in locations } |
        //|/{ choice[op](v) : op in Operations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
        rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             ( &/{ !choice[op](v1) : op in Operations} & &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	      )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & dle(v_1, v_2)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) -> dle(v_2, v_1) & !dle(v_1, v_2))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* isDataGreaterEq(ref1,ref2)
* Is the value of the node pointed-to by local variable ref1 greater-or-equal to
* the value of the node pointed-to by local variable ref2.
***/
%action isDataGreaterEq(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data >= " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
     otrnm(v) <->
     (|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
      |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
      //|/{ choice[op](v) : op in Operations } |
      rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
      : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             (  &/{ !choice[op](v1) : op in Operations} & &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	      )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & dle(v_2, v_1)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) -> dle(v_2, v_1))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
//    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
 //        & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %decompose
}

/***
* isDataLess(ref1,ref2,trnm)
* Is the value of the node pointed-to by local variable ref1 less than
* the value of the node pointed-to by local variable ref2.
***/
%action isDataLess(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data < " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
     otrnm(v) <->
     (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
      |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
     // |/{ choice[op](v) : op in Operations } |
      rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
      : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             (  &/{ !choice[op](v1) : op in Operations} & &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	 )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & dle(v_2, v_1)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & !A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) -> dle(v_2, v_1))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    //%message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

%action isDataEq1(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data == " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
           otrnm(v) <->
           (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
            |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
     //       |/{ choice[op](v) : op in Operations } |
            rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
            : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             ( &/{ !choice[op](v1) : op in Operations} &  &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	       )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & eq(v_1,v_2)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) ->
                   eq(v_1,v_2))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
//    %message [trnm(v)] (E(v1,tr) trnm(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,trnm](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
/***
* isDataEq(ref1,ref2,trnm)
* Is the value of the node pointed-to by local variable ref1 equal to
* the value of the node pointed-to by local variable ref2.
***/
%action isDataEq(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data == " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
           otrnm(v) <->
           (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
            |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
     //       |/{ choice[op](v) : op in Operations } |
            rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
            : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             ( &/{ !choice[op](v1) : op in Operations} &  &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	       )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & eq(v_1,v_2)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) ->
                   eq(v_1,v_2))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* isDataNotEq(ref1,ref2,trnm)
* Is the value of the node pointed-to by local variable ref1 not equal to
* the value of the node pointed-to by local variable ref2.
***/
%action isDataNotEq(ref1,ref2) {
    %param trnm in Threads
    %t "tr." + ref1 + "->data != " + tr + "." + ref2 + "->data" + " [" + trnm + "]"
    %frame_pre |/{
          otrnm(v) <->
      (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
       |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
     //  |/{ choice[op](v) : op in Operations } |
           rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
           : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> ((trnm(v1) | r_by[ref1, trnm](v1) | r_by[ref2,trnm](v1)) &
             ( &/{ !choice[op](v1) : op in Operations} &  &/{ !at[loc](v1) : loc in locations} 
	      & &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	     )) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f {r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2) & eq(v_1,v_2)}
    %p E(tr) tr_scheduled(tr) & trnm(tr)
         & !A(v_1,v_2) ((r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2)) ->
                    eq(v_1,v_2))
    %message [trnm(v)] (!E(v_1,v_2) (r_by[ref1,trnm](v_1) & r_by[ref2,trnm](v_2))) ->
             "possible null dereference of " + ref1 + " or " + ref2
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* assignNull(ref,trnm)
* ref = null where ref is a local field
***/
%action assignNull(ref) {
    %param trnm in Threads
    %t ref + " = null" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    {
         ref(w,o_1) = (tr_scheduled(w) ? 0 : ref(w,o_1))
         r_by[ref,trnm](o_1) = 0
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

//ref1 IS assumed to be null before assignment
%action assignRef(ref1, ref2) {
    %param trnm in Threads
    %t ref1 + " = " + ref2 + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) r_by[ref1,trnm](v)) -> "possible assignment to non-null field"
    {
      ref1(w,o_1) = (tr_scheduled(w) ? ref2(w, o_1) : ref1(w,o_1))
      foreach (otrnm in Threads-{trnm}) {
    	r_by[ref1, otrnm](v) = r_by[ref1, otrnm](v)
      }
      r_by_tr_sc(v) = r_by_tr_sc(v) 
    }
	%message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* assignRef(ref1,ref2,trnm)
* ref1 = ref2 where ref1 and ref2 are local fields
***/
//ref1 IS assumed to be null before assignment
%action assignRef1(ref1, ref2) {
    %param trnm in Threads
    %t ref1 + " = " + ref2 + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) r_by[ref1,trnm](v)) -> "possible assignment to non-null field"
    %message  (E(v1,tr) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & !outside(v1) &  r_by[curr,trnm](v1) & !markBit(v1) & !outside(tr)) -> "should have been marked b4"
    {
      ref1(w,o_1) = (tr_scheduled(w) ? ref2(w, o_1) : ref1(w,o_1))
      foreach (otrnm in Threads-{trnm}) {
    	r_by[ref1, otrnm](v) = r_by[ref1, otrnm](v)
      }
      r_by_tr_sc(v) = r_by_tr_sc(v)
      fromFail(tr) = (tr_scheduled(tr) ? choice[delete](tr)  & E(v1) r_by[curr,trnm](v1) & !markBit(v1) : fromFail(tr))
    }
    %message  (E(v1,tr) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & !outside(v1) & r_by[curr,trnm](v1) & !markBit(v1) & !outside(tr)) -> "should have been marked after " + tr
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %decompose
}

/****
* setChoice(op,trnm)
* Set operation choice to op.
***/
%action setChoice(op) {
    %param trnm in Threads
    %t "setChoice(" + op + ")" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(tr) trnm(tr) & |/{ choice[op2](tr) : op2 in Operations-{op}}) -> "Already performing another operation!"
    {
      choice[op](t) = choice[op](t) | tr_scheduled(t)
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/****
* isChoice(op,trnm)
* Is op the operation choice of tr.
***/
%action isChoice(op) {
    %param trnm in Threads
    %t "isChoice(" + op + ")" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr) & choice[op](tr)
    {
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/*******************
* ClearOp(trnm)
* null assignment to all local variables 
********************/
%action ClearOp() {
    %param trnm in Threads
    %t "ClearOp()" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    {
      wasLin(v) = (tr_scheduled(v) ? 0 : wasLin(v))
      michal(v) = (tr_scheduled(v) ? 0 : michal(v))
      fromFail(v) = (tr_scheduled(v) ? 0 : fromFail(v))
      foreach (op in Operations) {
          choice[op](o_1) = (tr_scheduled(o_1) ? 0 : choice[op](o_1))
      }
    }  
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/*******************
* Clear2(trnm)
* null assignment to all local variables except x_i 
********************/
//We clear all local fields, no matter which action was performed.
%action Clear2() {
    %param trnm in Threads
    %t "Clear2()" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) trnm(v) & wasLin(v)) -> "should never restart with wasLin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    {
      foreach (bool in BoolLocals) {
		bool(tr) = (tr_scheduled(tr) ? 0 : bool(tr))
      }
      foreach (fld in LocalFields-{x_i}) {
        fld(w,o_1) = (tr_scheduled(w) ? 0 : fld(w,o_1))
      }
      foreach (otrnm in Threads-{trnm}) {
        foreach (fld in LocalFields-{x_i}) {
           r_by[fld,otrnm](o_1) = r_by[fld,otrnm](o_1)  
        }
      }
    }
    %decompose
}

/*******************
* Clear(trnm)
* null assignment to all local variables 
********************/
//We clear all local fields, no matter which action was performed.
%action Clear() {
    %param trnm in Threads
    %t "Clear()" + " [" + trnm + "]"
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (E(v) trnm(v) & wasLin(v)) -> "should never restart with wasLin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    {
      foreach (bool in BoolLocals) {
		bool(tr) = (tr_scheduled(tr) ? 0 : bool(tr))
      }
      foreach (fld in LocalFields) {
        fld(w,o_1) = (tr_scheduled(w) ? 0 : fld(w,o_1))
      }
      foreach (otrnm in Threads-{trnm}) {
        foreach (fld in LocalFields) {
           r_by[fld,otrnm](o_1) = r_by[fld,otrnm](o_1)  
        }
      }
    }
  
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
    %decompose
}

/****************************
* verifySameRes(trnm)
* (res == res_seq)
*****************************/
%action verifySameRes() {
    %param trnm in Threads
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (!A(v) (r_by[res,trnm](v) <-> r_by[res_seq,trnm](v)))
             -> "operation results may differ\n"
    {
    }
}

/***
* updateNext(obj,ref,trnm)
* obj->n = ref where obj and ref are thread-local variables.
***/
//obj->n IS assumed to be null before assignment.
//Note: Updates are simplified due to this assumption. Is focus still needed?
%action updateNext(obj,ref) {
    %param trnm in Threads
    %t "updateNext(" + obj + "," + ref + "," + trnm + ")"
    %frame_pre |/{
            otrnm(v) <->
              (
       |/{ at[loc](v) : loc in locations } | 
       |/{ fld(v) : fld in BoolLocals } |
       |/{ fld(v) : fld in BoolFields } |               
       eq(v1,v2))
    : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[ref, trnm](v1) | r_by[obj,trnm](v1))
    	& ( &/{ !choice[op](v1) : op in Operations} &  &/{ !at[loc](v1) : loc in locations} & &/{ !fld(v1) :  fld in BoolLocals} 
	) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    //%f { r_by[obj,trnm](o_t) & rv[n](o_t,dst) & bn[n](dst,v) }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (!(E(o_t) r_by[obj,trnm](o_t))) -> "possible null dereference of " + obj
    %message [trnm(v)] (!E(o_1) r_by[ref,trnm](o_1))-> "possible null dereference of " + ref
    %message (E(o_1) r_by[obj,trnm](o_1) & markBit(o_1))-> "cant change succ of marked " + obj
    {
        rv[n](o_1,o_2) = (rv[n](o_1, o_2) ? !r_by[obj,trnm](o_1) | r_by[ref,trnm](o_2):
                      (r_by[obj,trnm](o_1) & r_by[ref,trnm](o_2)))

#define updateNext_bn_1(w1,w2) (bn[n](w1, w2) & !(bn[n](w1, o_1) & bn[n](o_1, w2) & o_1 != w2))
       bn[n](v_1,v_2) = E(o_1, r) r_by[ref,trnm](r) & r_by[obj,trnm](o_1) &
                           (updateNext_bn_1(v_1,v_2) | (updateNext_bn_1(v_1,o_1) & updateNext_bn_1(r, v_2)))
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* assignNextNull(obj,trnm)
* obj->n = null where obj is a thread-local variable.
***/
%action assignNextNull(obj) {
    %param trnm in Threads
    %t "assignNextNull(" + obj + "," + trnm + ")"
    // michal - t2 needs to see obj's outgoing edges. Should this be {E(o_2) rv[n](obj, o_2)} ?
    // maybe its enough for it to see obj?
    %frame_pre |/{
            otrnm(v) <->
                (
      // |/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
       |/{ at[loc](v) : loc in locations } | 
       // |/{ choice[op](v) : op in Operations } |
       |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |
       eq(v1,v2) | dle(v1,v2))
    : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[obj,trnm](v1)) & 
    	( &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	   &/{ !choice[op](v1) : op in Operations} & &/{ !at[loc](v1) : loc in locations} ) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { r_by[obj,trnm](o_t) & rv[n](o_t,dst) & bn[n](dst,v) }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (!(E(o_t) r_by[obj,trnm](o_t))) -> "possible null dereference of " + obj
    {
        rv[n](o_1,o_2) = (rv[n](o_1,o_2) & !r_by[obj,trnm](o_1))
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* Insert_Seq(ref,trnm)
* insertion of (the value of) the node pointed-to by local variable ref
* to sequential set. Insertion is successful provided the set doesn't already include
* an equal value.
***/
%action Insert_Seq(ref) {
    %param trnm in Threads
    %t "insert seq" + " [" + trnm + "]"
    %frame_pre |/{
        otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr} } |
        |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } |
        |/{ fld(v) : fld in BoolFields } |
         // |/{ choice[op](v) : op in Operations } |
         bn[n](v1,v2))
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> 
        ((trnm(v1) | member(v1) | r_by[ref,trnm](v1)) & (
	       &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	 &/{ !at[loc](v1) : loc in locations}))) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { &/{r_by[x_i, trnm](v1) & r_by[x_i, otrnm](v2) & eq(v1,v2) : otrnm in Threads-{trnm} } }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    //message given if ref==null since the action uses the value of the node
    //pointed-to by ref
    %message [trnm(v1)] (!(E(o_t) r_by[ref,trnm](o_t))) -> "possible null dereference of " + ref
    {

#define SHOULD_INSERT (A(vr,vm) (r_by[ref,trnm](vr) & member(vm)) -> !(eq(vr,vm)| vr == vm))
        member(o_1) = member(o_1) | (SHOULD_INSERT & E(w) tr_scheduled(w) & ref(w, o_1))
        res_seq(w,o_1) = (tr_scheduled(w) ? (SHOULD_INSERT ? ref(w, o_1) : 0) : res_seq(w,o_1))
    }
    %message (E(v) rt[Head](v) & !r_by[Head](v) & !r_by[Tail](v) & !member(v)) -> "member inv1"
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
  %message [t2(v)] (E(v) !outside(v) & memberEq[x_i,t2](v) & ! memberEq[x_i,t2](v)) -> "should not be 1/2"
  %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* Delete_Seq(ref,trnm)
* Deletion of THE VALUE OF the node pointed-to by local variable ref
* from the sequential set.
* Action includes both successful and failed deletion (failed = value not in set).
***/
%action Delete_Seq(ref) {
    %param trnm in Threads
    %t "delete seq" + " [" + trnm + "]"
    %frame_pre |/{
        otrnm(v) <->
       (|/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } |
        |/{ fld(v) : fld in BoolFields } |
         dle(v1,v2) | bn[n](v1,v2))
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) |  |/{(trnm(v1) <-> 
        ((trnm(v1) | member(v1) | r_by[ref,trnm](v1)) & (
         &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	 &/{ !at[loc](v1) : loc in locations}))) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { r_by[x_i, trnm](v1) & eq(v1,v2) }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v1)] (!(E(o_t) r_by[ref,trnm](o_t))) -> "possible null dereference of " + ref
    %message [trnm(v1)] (E(v_1,u_1,u_2)
                 (r_by[ref,trnm](v_1) & member(u_1) & (eq(v_1,u_1) | v_1 == u_1)
                                       & member(u_2) & (eq(v_1,u_2) | v_1 == u_2)
                                       & u_1!=u_2 ))
             -> "possible duplicate values in sequential set"
    {
       member(o_1) = member(o_1) & !E(o_2)(r_by[ref,trnm](o_2) & (eq(o_1,o_2) | o_1 == o_2 ))
       res_seq(w,o_1) = (tr_scheduled(w) ?
          member(o_1) & E(o_2)(ref(w, o_2) & (eq(o_1,o_2) | o_1 == o_2)) : res_seq(w,o_1))
       foreach (otrnm in Threads-{trnm}) {
         r_by[res_seq, otrnm](v) = r_by[res_seq, otrnm](v)
       }
    }
    %message (E(v) rt[Head](v) & !r_by[Head](v) & !r_by[Tail](v) & !member(v)) -> "member inv1"
    //%message [trnm(v)] (!A(v) r_by[res,trnm](v) <-> r_by[res_seq,trnm](v)) -> "res_seq is different from res"
  %message [trnm(v)] (E(v) !outside(v) & memberEq[x_i,trnm](v) & ! memberEq[x_i,trnm](v)) -> "should not be 1/2"
  %message [t2(v)] (E(v) !outside(v) & memberEq[x_i,t2](v) & ! memberEq[x_i,t2](v)) -> "should not be 1/2"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

/***
* SuccCAS_Next(obj,oldVal,ref,trnm)
* Successful CAS where obj is a thread-local variable and fld is n.
* obj->n == oldVal and we assign obj->n = ref.
***/
//obj->n is not assumed to be null before assignment.
%action SuccCAS_NextBoolean(obj, bfield, oldVal, oldLBool, newVal, newLBool) {
    %param trnm in Threads
    %t "SuccCAS_NextBoolean(" + obj + "," + bfield + "," + oldVal + "," + oldLBool + "," + newVal + "," + newLBool + ")"
    %frame_pre |/{
     otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{curr,x_i} } |
        |/{ at[loc](v) : loc in locations } | // |/{ choice[op](v) : op in Operations } |
      eq(v1,v2) | member(v1))
      : otrnm in Threads-{trnm} }

    %compose trnm(v1) | |/{(trnm(v1) <->
      ((trnm(v1) | r_by[obj,trnm](v1) | r_by[newVal, trnm](v1) | r_by[oldVal,trnm](v1) )) &
      (
        &/{ !r_by[fld](v1) : fld in GlobalFields }  &
	 &/{ !at[loc](v1) : loc in locations} & !member(v1)) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { r_by[obj,trnm](o_t) & bfield(o_t),
	 r_by[obj,trnm](o_t) & r_by[oldVal,trnm](o_f) & rv[n](o_t,o_f),
	 r_by[obj,trnm](o_t) & bn[n](u,o_t),
	 r_by[oldVal,trnm](o_r) & bn[n](o_r,u),
	 r_by[newVal,trnm](o_r) & bn[n](o_r,u)
       }
    %p E(tr) tr_scheduled(tr) & trnm(tr) &
    	(A(o_f) ((E(o_t) r_by[obj,trnm](o_t) & rv[n](o_t,o_f)) <-> r_by[oldVal,trnm](o_f))) & 
       	((E(o_f) r_by[obj,trnm](o_f) & bfield(o_f)) <-> oldLBool(tr))
    %message (!(E(o_t) r_by[obj,trnm](o_t))) -> "possible null dereference of " + obj
    %message (E(o_1) r_by[obj,trnm](o_1) & markBit(o_1))-> "cant change succ of marked " + obj
    {

       rv[n](o_1,o_2) = ( r_by[obj,trnm](o_1) ?
                           r_by[newVal,trnm](o_2) : rv[n](o_1,o_2) ) 
       #define CAS_bn_1(w1,w2) (bn[n](w1, w2) & !(bn[n](w1, o_1) & bn[n](o_1, w2) & o_1 != w2))
       bn[n](v_1,v_2) = E(o_1, r) r_by[newVal,trnm](r) & r_by[obj,trnm](o_1) &
                        (CAS_bn_1(v_1,v_2) | (CAS_bn_1(v_1,o_1) & CAS_bn_1(r, v_2)))
					  
       bfield(v) = (r_by[obj,trnm](v) ? (E(tr) tr_scheduled(tr) & newLBool(tr)) : bfield(v))
       michal(v) = michal(v) | tr_scheduled(v)  
   }
  %message [trnm(v)] (E(v) !outside(v) & member(v) & (A(w) !bn[n](v,w))) -> "flying member"
  %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in cas"
    %decompose
}

%action SuccCAS_NextOnlyBoolean(obj, bfield, oldVal, oldLBool, newLBool) {
    %param trnm in Threads
    %t "SuccCAS_NextBoolean(" + obj + "," + bfield + "," + oldVal + "," + oldLBool + "," + newLBool + ")"
    %frame_pre |/{
     otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
        |/{ at[loc](v) : loc in locations } | |/{ choice[op](v) : op in Operations } |
      eq(v1,v2) | member(v1))
      : otrnm in Threads-{trnm} }

    %compose trnm(v1) | |/{(trnm(v1) <->
      ((trnm(v1) | r_by[obj,trnm](v1) | r_by[oldVal,trnm](v1) )) &
      (
        &/{ !r_by[fld](v1) : fld in GlobalFields }  &
	 &/{ !at[loc](v1) : loc in locations} & !member(v1) ) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { r_by[obj,trnm](o_t) & bfield(o_t),
	 	 r_by[obj,trnm](o_t) & r_by[oldVal,trnm](o_f) & rv[n](o_t,o_f) }
    %p E(tr) tr_scheduled(tr) & trnm(tr) &
    	(A(o_f) ((E(o_t) r_by[obj,trnm](o_t) & rv[n](o_t,o_f)) <-> r_by[oldVal,trnm](o_f))) & 
       	((E(o_f) r_by[obj,trnm](o_f) & bfield(o_f)) <-> oldLBool(tr))
    %message (!(E(o_t) r_by[obj,trnm](o_t))) -> "possible null dereference of " + obj
    {
       bfield(v) = (r_by[obj,trnm](v) ? (E(tr) tr_scheduled(tr) ) : bfield(v))
//       bfield(v) = (r_by[obj,trnm](v) ? (E(tr) tr_scheduled(tr) & newLBool(tr)) : bfield(v))
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}


%action FailCAS_NextBoolean(obj, bfield, oldVal, oldLBool, newVal, newLBool) {
    %param trnm in Threads
    %t "FailCAS_NextBoolean(" + obj + "," + bfield + "," + oldVal + "," + oldLBool + "," + newVal + "," + newLBool + ")"
    %frame_pre |/{
     otrnm(v) <->
      (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
       |/{ at[loc](v) : loc in locations } | 
       // |/{ choice[op](v) : op in Operations } |
       eq(v1,v2) | member(v1))
       : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <->
      ((trnm(v1) | r_by[obj,trnm](v1) | r_by[newVal, trnm](v1) | r_by[oldVal,trnm](v1) )) &
      (
        &/{ !r_by[fld](v1) : fld in GlobalFields }  &
         &/{ !at[loc](v1) : loc in locations} & !member(v1) ) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %f { r_by[obj,trnm](o_t) & r_by[oldVal,trnm](o_f) & rv[n](o_t,o_f), 
         r_by[obj,trnm](o_t) & bfield(o_t) }
    %p E(tr) tr_scheduled(tr) & trnm(tr) &
    	!((A(o_f) ((E(o_t) r_by[obj,trnm](o_t) & rv[n](o_t,o_f)) <-> r_by[oldVal,trnm](o_f))) & 
    	((E(o_f) r_by[obj,trnm](o_f) & bfield(o_f)) <-> oldLBool(tr)))
    %message (!(E(o_t) r_by[obj,trnm](o_t))) -> "possible null dereference of " + obj
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}


%action isNull(ref) {
    %param trnm in Threads
    %t ref + "== null" + " [" + trnm + "]"
    %frame_pre |/{
            otrnm(v) <->
            (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
             |/{ at[loc](v) : loc in locations } | // |/{ choice[op](v) : op in Operations } |
        	 |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |             
            eq(v1,v2))
            : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <->
        (trnm(v1) | r_by[ref, trnm](v1)) & ( 
 &/{ !choice[op](v1) : op in Operations} & 	&/{ !at[loc](v1) : loc in locations} &
	&/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields }
	) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %p E(tr) tr_scheduled(tr) & trnm(tr) & !E(v) r_by[ref,trnm](v)


    {
    }


//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}


%action isNotNull(ref) {
    %param trnm in Threads
    %t ref + "!= null" + " [" + trnm + "]"
    %frame_pre |/{
            otrnm(v) <->
            (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
             |/{ at[loc](v) : loc in locations } | // |/{ choice[op](v) : op in Operations } |
        	 |/{ fld(v) : fld in BoolLocals } | |/{ fld(v) : fld in BoolFields } |             
            eq(v1,v2))
            : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> 
        (trnm(v1) | r_by[ref, trnm](v1)) & (
	 &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	 &/{ !choice[op](v1) : op in Operations} & &/{ !at[loc](v1) : loc in locations} ) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    %p E(tr) tr_scheduled(tr) & trnm(tr) & E(v) r_by[ref,trnm](v)


    {
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

%action getBooleanLocalFromField(localb, ref, fieldb) {
    %param trnm in Threads
    %t localb + " = " +  ref + "." + fieldb + " [" + trnm + "]"
    %f { r_by[ref,trnm](v) & fieldb(v) }
    %p E(tr) tr_scheduled(tr) & trnm(tr)
    %message [trnm(v)] (!(E(o_t) r_by[ref,trnm](o_t))) -> "possible null dereference of " + ref
    {
        localb(tr) = (tr_scheduled(tr) ? E(v) ref(tr, v) & fieldb(v) : localb(tr))
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

%action wasLinearized() {
    %param trnm in Threads
    %t "was Lin. " + trnm
    %frame_pre |/{
      otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
        |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } |
        |/{ fld(v) : fld in BoolFields } |
        //|/{ choice[op](v) : op in Operations } |
        rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
         : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1)) & (
	       &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
         &/{ !at[loc](v1) : loc in locations}  )) & otrnm(v2) : otrnm in Threads-{trnm}}
    %p E(tr) tr_scheduled(tr) & trnm(tr) & wasLin(tr)
    { }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

%action wasNotLinearized() {
    %param trnm in Threads
    %t "was Not Lin. " + trnm
    %frame_pre |/{
      otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields } |
        |/{ at[loc](v) : loc in locations } |
        |/{ fld(v) : fld in BoolLocals } |
        |/{ fld(v) : fld in BoolFields } |
        //|/{ choice[op](v) : op in Operations } |
        rv[n](v1,v2) | bn[n](v1,v2) | eq(v1,v2))
         : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1)) & 
    	(
	 &/{ !fld(v1) :  fld in BoolLocals} & &/{ !fld(v1) :  fld in BoolFields } &
	 &/{ !at[loc](v1) : loc in locations} ) ) & otrnm(v2) : otrnm in Threads-{trnm}}
    //%compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1))) & otrnm(v2) : otrnm in Threads-{trnm}}
    %p E(tr) tr_scheduled(tr) & trnm(tr) & !wasLin(tr)
    { }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

#define LIN_DELETE_CURR_FOR_DELETE \
       &/{ E(otr) otrnm(otr) &  choice[delete](otr) & !wasLin(otr) & \
       ((A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[curr,otrnm](v_2) -> eq(v_1, v_2)) & (E(v1) r_by[curr,otrnm](v1))) & \
       A(v_1, v_2) r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](v_2) -> !dle(v_2, v_1) : otrnm in Threads-{trnm}}

%action LinearizationInDeleteForOtherThreadDelete() {
    %param trnm in Threads
    %t "lin in delete for delete by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (|/{ at[loc](v) : loc in locations } // |
       // |/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr,res_seq} }
       ) : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) &
             otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,trnm](v_1) & r_by[curr, otrnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr, otrnm](u_1) & !dle(u_1,v_1)
         }
       }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & LIN_DELETE_CURR_FOR_DELETE
    {
        wasLin(v) = wasLin(v) | |/{ !tr_scheduled(v) & isthread(v) & otrnm(v) : otrnm in Threads-{trnm}}
        res_seq(t_1, o_1) = |/ {(otrnm(t_1) & !tr_scheduled(t_1) & isthread(t_1) ?
             member(o_1) & (E(o_2) r_by[x_i,otrnm](o_2) & (eq(o_1,o_2) | o_1 == o_2)) :
             res_seq(t_1, o_1)) :otrnm in Threads-{trnm}}
    }
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

#define LIN_DELETE_FOR_FIND \
       &/{ E(otr) otrnm(otr) &  choice[find](otr) & !wasLin(otr) & \
       ((A(v) r_by[curr,trnm](v) <-> r_by[curr,otrnm](v)) & (E(v1) r_by[curr,otrnm](v1))) & \
       (A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[x_i,otrnm](v_2) -> eq(v_1, v_2)) : otrnm in Threads-{trnm}}

                                                      

%action LinearizationInDeleteForOtherThreadFind() {
    %param trnm in Threads
    %t "lin in delete for find by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       ( //      |/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr,res_seq} } |
        |/{ at[loc](v) : loc in locations } )
         : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,trnm](v_1) & r_by[curr, otrnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr, otrnm](u_1) & dle(v_1,u_1)
       }
    }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & LIN_DELETE_FOR_FIND 
    {
        // if we are t1 - we dont know who t2 is, it might be us. This is what we use the tr_sched for
        wasLin(v) = wasLin(v) | |/{ !tr_scheduled(v) & isthread(v) & otrnm(v) : otrnm in Threads-{trnm}}
        res_seq(t_1, o_1) = |/ {(otrnm(t_1) & !tr_scheduled(t_1) & isthread(t_1) ? member(o_1) & (E(o_2) r_by[x_i,otrnm](o_2) & (eq(o_1,o_2) | o_1 == o_2)) : res_seq(t_1, o_1)) :otrnm in Threads -{trnm}}
    }
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in delete for find"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

#define LIN_INSERT_FOR_FIND \
       &/{ E(otr) otrnm(otr) &  choice[find](otr) & !wasLin(otr) & \
       ((A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[curr,otrnm](v_2) -> dle(v_1, v_2)) & (E(v1) r_by[curr,otrnm](v1))) & \
       (A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[x_i,otrnm](v_2) -> eq(v_1, v_2)) : otrnm in Threads-{trnm}}

%action LinearizationInInsertForOtherThreadFind() {
    %param trnm in Threads
    %t "lin in insert for find by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (|/{ at[loc](v) : loc in locations }// |
       //|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr,res_seq} } 
       ) : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](u_1) & dle(v_1,u_1)
       }
    }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & LIN_INSERT_FOR_FIND
    {
        // if we are t1 - we dont know who t2 is, it might be us. This is what we use the tr_sched for
    	wasLin(v) = wasLin(v) | |/{ !tr_scheduled(v) & isthread(v) & otrnm(v) : otrnm in Threads-{trnm}}
        res_seq(t_1, o_1) = |/ {(otrnm(t_1) & !tr_scheduled(t_1) & isthread(t_1) ? member(o_1) & (E(o_2) r_by[x_i,otrnm](o_2) & (eq(o_1,o_2) | o_1 == o_2)) : res_seq(t_1, o_1)) :otrnm in Threads -{trnm}}
    }
    %message [t2(v)] (E(o_1) member(o_1) & (E(o_2) r_by[x_i,t2](o_2) & (eq(o_1,o_2) | o_1 == o_2))) -> "res_seq should have been null"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

#define LIN_INSERT_FOR_DELETE \       
       &/{ E(otr) otrnm(otr) &  choice[delete](otr) & !wasLin(otr) & \
       ((A(v_1, v_2) r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](v_2) -> dle(v_1, v_2) & !dle(v_2, v_1)) & (E(v1) r_by[curr,otrnm](v1))) & \
       (A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[x_i,otrnm](v_2) -> eq(v_1, v_2)) : otrnm in Threads-{trnm}}

%action LinearizationForOtherThreadDelete() {
    %param trnm in Threads
    %t "lin for delete by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (//|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr,res_seq} } |
       |/{ at[loc](v) : loc in locations } )
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](u_1) & dle(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](u_1) & !dle(u_1,v_1)
       }
    }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & LIN_INSERT_FOR_DELETE
    {
        wasLin(v) = wasLin(v) | |/{ !tr_scheduled(v) & isthread(v) & otrnm(v) : otrnm in Threads-{trnm}}
        res_seq(t_1, o_1) = |/ {(otrnm(t_1) & !tr_scheduled(t_1) & isthread(t_1) ? 
		member(o_1) & (E(o_2) r_by[x_i,otrnm](o_2) & (eq(o_1,o_2) | o_1 == o_2)) : res_seq(t_1, o_1)) :otrnm in Threads-{trnm}}
    }
  %message [trnm(v)] (E(v) !outside(v) & member(v) & (A(w) !bn[n](v,w))) -> "flying member"
  %message [trnm(v)] (E(v) !outside(v) & r_by_tr_sc(v) & !rt[Head](v)) -> "not rt head memflying member"
//    %message [t2(v)] (E(v1,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & !rt[Head](v1)) -> "should have been lin"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

#define LIN_DELETE_FOR_INSERT \       
       &/{ E(otr) otrnm(otr) &  choice[insert](otr) & !wasLin(otr) & \
       ((A(v) (r_by[curr,trnm](v) <-> r_by[curr,otrnm](v))) & (E(v1) r_by[curr,otrnm](v1))) & \
       (A(v_1, v_2) r_by[x_i,trnm](v_1) & r_by[x_i,otrnm](v_2) -> eq(v_1, v_2)) : otrnm in Threads-{trnm}} 

%action LinearizationForOtherThreadInsert() {
    %param trnm in Threads
    %t "lin for insert by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (
       //|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr,res_seq} } |
        |/{ at[loc](v) : loc in locations } )
         : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,trnm](v_1) & r_by[curr, otrnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr, otrnm](u_1) & dle(v_1,u_1)
         }
       }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & LIN_DELETE_FOR_INSERT
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    {
        wasLin(v) = wasLin(v) | |/{ !tr_scheduled(v) & isthread(v) & otrnm(v) : otrnm in Threads-{trnm}}
        res_seq(t_1, o_1) = |/ {(otrnm(t_1) & isthread(t_1) & !tr_scheduled(t_1) ?
	    (E(o_2, o_3) r_by[x_i,otrnm](o_2) & member(o_3) & (eq(o_2,o_3) | o_2 == o_3) ? 0 
            : r_by[x_i,trnm](o_1)) 
            : res_seq(t_1, o_1)) :otrnm in Threads-{trnm}}
    }
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in delete for insert"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message  (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}

%action isNotLinearizationInInsertForOtherThread() {
    %param trnm in Threads
    %t "no lin for my insert by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       ( //|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr} } |
       |/{ at[loc](v) : loc in locations } |
        rv[n](v1,v2) | bn[n](v1,v2) )
        : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](u_1) & dle(v_1,u_1),
           r_by[x_i,otrnm](v_1) & r_by[curr,otrnm](u_1) & !dle(u_1,v_1)
     	 }
       }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & !(LIN_INSERT_FOR_DELETE) & !(LIN_INSERT_FOR_FIND)
    {
    }
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[delete](tr) & memberEq[x_i,t2](v1) & r_by[curr,t2](v2) & !dle(v2,v1)) -> "will fall in lin"
}

%action isNotLinearizationInDeleteForOtherThread() {
    %param trnm in Threads
    %t "no lin for my delete by " + " [" + trnm + "]"
    %frame_pre |/{
      otrnm(v) <->
       (
       //|/{ r_by[oref,otrnm](v) | (otrnm(v1) & oref(v1,v2)) : oref in LocalFields-{x_i,curr} } |
        |/{ at[loc](v) : loc in locations } )
         : otrnm in Threads-{trnm} }
    %compose trnm(v1) | |/{(trnm(v1) <-> (trnm(v1) | r_by[curr,trnm](v1) | r_by[x_i, trnm](v1) |  member(v1)) &
             (&/{ !at[loc](v1) : loc in locations} ) ) & 
	     otrnm(v2) : otrnm in Threads-{trnm}}
    %f { foreach (otrnm in Threads - {trnm}) {
           r_by[x_i,otrnm](v_1) & r_by[x_i, trnm](u_1) & eq(v_1,u_1)
       }
    }
    %p E(tr) tr_scheduled(tr) & trnm(tr) & !(LIN_DELETE_FOR_INSERT) & !(LIN_DELETE_FOR_FIND)
    {
    }
    %message (E(v1,tr,v2) trnm(tr) & tr_scheduled(tr) & choice[delete](tr) & r_by[curr,trnm](v1) & r_by[res,trnm](v2) & !markBit(v1)) -> "should have been marked in is not delete "
    %message [t2(v)] (E(tr) t2(tr) & choice[find](tr) & !wasLin(tr) & E(v1,v2) 
            r_by[x_i,t2](v1) & r_by[curr,t2](v2) & !rt[Head](v2) & eq(v1,v2)) -> "should have been linearized"
    %message [t2(v)] (E(v1,v2,tr) t2(tr) & !wasLin(tr) & choice[insert](tr) & r_by[curr,t2](v1) & r_by[x_i,t2](v2) 
         & eq(v1,v2) & !rt[Head](v1)) -> "should have been lin"
    %message (E(v1) !dnode(v1) & rt[Tail](v1) & !r_by[Tail](v1) & !rt[Head](v1) & !member(v1) & !markBit(v1) & !outside(v1)) -> "should have been makred"
    %decompose
}
