//Licensed Materials - Property of IBM
//5724-D15
//(C) Copyright IBM Corporation 2004. All Rights Reserved. 
//Note to U.S. Government Users Restricted Rights:  Use, duplication or disclosure restricted by GSA ADP  Schedule Contract with IBM Corp. 
//                                                                          
//--------------------------------------------------------------------------- 

package tvla.analysis.interproc.api.tvlaadapter;

import java.util.Collection;
import java.util.Map;

import tvla.analysis.AnalysisStatus;
import tvla.analysis.interproc.api.tvlaadapter.abstraction.ITVLAVocabulary;
import tvla.analysis.interproc.api.tvlaadapter.transformers.BinaryTransformer;
import tvla.analysis.interproc.api.tvlaadapter.transformers.TransformerFactory;
import tvla.analysis.interproc.api.tvlaadapter.transformers.UnaryTransformer;
import tvla.analysis.interproc.api.utils.IntArrayUtils;
import tvla.analysis.interproc.api.utils.TVLAAPIAssert;
import tvla.analysis.interproc.api.utils.TVLAAPIDebugControl;
import tvla.analysis.interproc.api.utils.TVLAAPITrace;
import tvla.analysis.interproc.semantics.ActionInstance;
import tvla.api.ITVLAAPI.ITVLATabulatorServices;
import tvla.api.ITVLAAPI.ITVLAApplierListener;
import tvla.api.ITVLATransformers.ITVSStagedTransformer;
import tvla.core.HighLevelTVS;
import tvla.core.Combine.INullaryCombiner;
import tvla.util.HashMapFactory;

/**
 * This class transforms applications of actions as exported by the api, 
 * i.e., as transfromers operating on indexes of TVSs
 * into applications of the underlying actions on HighLevelTVSs
 * 
 * In addition, it transforms the message generated by TVLA actios into events sent to 
 * registered clients
 * 
 * @author maon
 *
 */

public class AbstractInterpreterAdapter implements  ITVLAApplierAdapter {
  private static final int DEBUG_LEVEL = TVLAAPIDebugControl.getDebugLevel(4);

  protected final TVSRepository repository; 
  protected final AbstractInterpreter interpreter;
   
  protected boolean hasListeners;
  /**
   * Map used to get messages from the underlying tvla actions.
   * The map is resued accrros all actions
   */     
  private final Map msgs;
  
  /**
   * Generates the transformers by wrapping an action with an API object. 
   */
  protected TransformerFactory transformerFactory;
  
  
  protected MessageDispatcher msgMngr;
  
  AbstractInterpreterAdapter(
      ITVLAVocabulary voc,
      TVSRepository repository, 
      ITVLATabulatorServices engine) {
    this.repository = repository;
    
    
    this.hasListeners = false;
    this.msgs = HashMapFactory.make(4);     
    this.msgMngr = new MessageDispatcher();

    this.interpreter = new AbstractInterpreter(voc, engine);
}
  
  
  /****************************************************************
   * Listeners etc.
   ****************************************************************/
  
  public boolean registerListner(ITVLAApplierListener listener) {
    if (listener == null)
      return false;
    
    boolean succ = msgMngr.registerListner(listener);
    this.hasListeners = this.hasListeners || succ;
    
    return succ;
  }
  
  
  private void reportMessages(ITVSStagedTransformer transformer, int input) {
    if (0 < DEBUG_LEVEL)
      TVLAAPIAssert.debugAssert(! msgs.isEmpty());
    
    msgMngr.reportMessages(transformer, input, msgs);
    msgs.clear();
  }
  
  private void reportMessages(ITVSStagedTransformer transformer, int input1, int input2) {
    if (0 < DEBUG_LEVEL)
      TVLAAPIAssert.debugAssert(! msgs.isEmpty());
    
    msgMngr.reportMessages(transformer, input1, input2, msgs);      
    msgs.clear();
  }
  
 
  
  
  
  /****************************************************************
   * Applier interface for transformers
   ****************************************************************/
  
  public int[] apply(
      UnaryTransformer governingTransformer, 
      int tvsId1) {
    return apply(
        governingTransformer, 
        governingTransformer.actionInstance, 
        tvsId1);     
  }
  
  public  int[] apply(
      UnaryTransformer governingTransformer, 
      int in[])  {
    return apply(
        governingTransformer, 
        governingTransformer.actionInstance, 
        in);     
  }
  
  
  public  int[] apply(
      BinaryTransformer governingTransformer, 
      int tvsId1, 
      int tvsId2) {
    return apply(
        governingTransformer.nullaryCombiner, 
        governingTransformer, 
        governingTransformer.binaryActionInstance, 
        tvsId1, 
        tvsId2);   
  }
  
  public  int[] apply(
      BinaryTransformer governingTransformer, 
      int tvsId1[], 
      int tvsId2) {
    
    return apply(
        governingTransformer.nullaryCombiner, 
        governingTransformer, 
        governingTransformer.binaryActionInstance, 
        tvsId1, 
        tvsId2);     
  }
  
  
  /****************************************************************
   * Applier implementation 
   ****************************************************************/
  
  public int[] apply(ITVSStagedTransformer governingTransformer, ActionInstance unaryAction, int tvsId) {
    if (2 < DEBUG_LEVEL)
      TVLAAPITrace.tracePrintln("TVALAPIImpl: apply " + unaryAction.getMacroName(true) + 
          " to TVS id = " + tvsId + " == " + repository.getTVS(tvsId).toString());
    
    HighLevelTVS input = repository.getTVS(tvsId);
    if (input == null)
      return null;
    
    
    Collection ret = interpreter.apply(unaryAction,input, msgs);
    if (!msgs.isEmpty() && hasListeners)
      reportMessages(governingTransformer, tvsId);
    
    if (ret.isEmpty())
      return null;
    
    int[] res = repository.addTVSs(ret);
    
    if (2 < DEBUG_LEVEL) {
      if (res == null)
        TVLAAPITrace.tracePrintln("TVALAPIImpl:  action returns null!");
      else {
        TVLAAPITrace.tracePrint("TVALAPIImpl:  action returns:");
        for (int i=0; i<res.length; i++)
          TVLAAPITrace.tracePrint("  TVS id = " + res[i] + " == " + repository.getTVS(res[i]).toString());
        TVLAAPITrace.tracePrintln("");
      }
    }
    
    return res;
  }
  
  public int[] apply(ITVSStagedTransformer governingTransformer, ActionInstance unaryActions, int[] in) {
    int[][] res = new int[in.length][];
    int resSize = 0;
    int numOfValidResults = 0;
    
    for (int i=0; i<in.length; i++) {
      if (5 < DEBUG_LEVEL) {
        TVLAAPITrace.tracePrintln(
            " Applying " + governingTransformer.toString() + 
            " to TVS id = " + in[i] + " == " + repository.getTVS(in[i]).toString());
      }
      
      int ret[] = apply(governingTransformer, unaryActions, in[i]);
      
      if (ret == null) {
        if (5 < DEBUG_LEVEL) {
          TVLAAPITrace.tracePrintln(governingTransformer.toString() + " on " + in[i] + " Resulting in NULL!");
        }
      }
      else {
        if (5 < DEBUG_LEVEL) {
          TVLAAPITrace.tracePrintln(governingTransformer.toString() + " on " + in[i] + " Resulting in ... ");
          for (int j=0; j < ret.length ; j++)
            TVLAAPITrace.tracePrintln(" index = " + ret[j] + " TVS = " + repository.getTVS(ret[j]).toString());
        }
        
        resSize += ret.length;            
        res[numOfValidResults] = ret;
        numOfValidResults++;
      }
    }   
    
    if (0 < DEBUG_LEVEL) 
      TVLAAPIAssert.debugAssert((numOfValidResults == 0 && resSize == 0) ||(numOfValidResults > 0 && resSize > 0));

    if (numOfValidResults == 0)
      return null;
    
    int[] ret = IntArrayUtils.union(res, numOfValidResults);
    
    if (5 < DEBUG_LEVEL) {
      if (ret == null)
        TVLAAPITrace.tracePrintln("\n apply union == null");
      else {
        TVLAAPITrace.tracePrintln("unary apply on int[]: " +  governingTransformer.toString() + " apply union ... ");
        for (int j=0; j<ret.length; j++)
          TVLAAPITrace.tracePrintln(" index = " + ret[j] + " TVS = " + repository.getTVS(ret[j]).toString());
      }
    }
    
    return ret;
  }
  
  
  protected int[] apply(INullaryCombiner nullaryCombiner, ITVSStagedTransformer governingTransformer,  ActionInstance actionInstance, int tvsId1, int tvsId2) {
    if (2 < DEBUG_LEVEL) {
      TVLAAPITrace.tracePrintln("TVLA: performing binary action " + actionInstance.toString() + 
          " on tvsId1 " + tvsId1 + " and tvsId2 " + tvsId2);
    }
    
    HighLevelTVS input1 = repository.getTVS(tvsId1);
    HighLevelTVS input2 = repository.getTVS(tvsId2);
    
    if (2 < DEBUG_LEVEL) {
      TVLAAPITrace.tracePrintln(" tvsId1 " + tvsId1 + " = " + input1);
      TVLAAPITrace.tracePrintln(" tvsId2 " + tvsId2 + " = " + input2);
    }
    
    
    if (input1 == null || input2 == null) {
      if (2 < DEBUG_LEVEL) 
        TVLAAPITrace.tracePrintln("TVLA: binary action retirns null");
      
      return null;
    }
    
    Collection ret = interpreter.applyCombine(nullaryCombiner, actionInstance, input1, input2, msgs);
    if (!msgs.isEmpty() && hasListeners) 
      reportMessages(governingTransformer, tvsId1, tvsId2);
    
    if (ret.isEmpty())
      return null;
    
    int[] res = repository.addTVSs(ret);
    
    if (2 < DEBUG_LEVEL) {
      if (res == null)
        TVLAAPITrace.tracePrintln("TVLA: action returns null!");
      else {
        TVLAAPITrace.tracePrint("TVLA: action returns:");
        for (int i=0; i<res.length; i++)
          TVLAAPITrace.tracePrint("   TVS id = " + res[i] + repository.getTVS(res[i]).toString());
        TVLAAPITrace.tracePrintln("");
      }
    }
    
    return res;
  }
  
  
  public int[] apply(
      INullaryCombiner nullaryCombiner, 
      ITVSStagedTransformer governingTransformer, 
      ActionInstance binaryActions, 
      int[] in1, 
      int in2) {
    int[][] res = new int[in1.length][];
    int resSize = 0;
    int numOfValidResults = 0;
    
    for (int i=0; i<in1.length; i++) {
      if (5 < DEBUG_LEVEL) {
        TVLAAPITrace.tracePrintln(
            " Applying " + governingTransformer.toString() + 
            " to TVS id = " + in1[i] + " == " + repository.getTVS(in1[i]).toString());
      }
      
      int ret[] = apply(nullaryCombiner, governingTransformer, binaryActions, in1[i], in2);
      
      if (ret == null) {
        if (5 < DEBUG_LEVEL) {
          TVLAAPITrace.tracePrintln(governingTransformer.toString() + " on " + in1[i] + ", " + in2 + " Resulting in NULL!");
        }
      }
      else {
        if (5 < DEBUG_LEVEL) {
          TVLAAPITrace.tracePrintln(governingTransformer.toString() + " on " + in1[i] + ", " + in2 + " Resulting in ... ");
          for (int j=0; j < ret.length ; j++)
            TVLAAPITrace.tracePrintln(" index = " + ret[j] + " TVS = " + repository.getTVS(ret[j]).toString());
        }
        
        resSize += ret.length;            
        res[numOfValidResults] = ret;
        numOfValidResults++;
      }
    }   
    
    TVLAAPIAssert.debugAssert((numOfValidResults == 0 && resSize == 0) ||(numOfValidResults > 0 && resSize > 0));
    if (numOfValidResults == 0)
      return null;
    
    int[] ret = IntArrayUtils.union(res, numOfValidResults);
    
    if (5 < DEBUG_LEVEL) {
      if (ret == null)
        TVLAAPITrace.tracePrintln("\n apply union == null");
      else {
        TVLAAPITrace.tracePrintln("binary apply on int[]: " +  governingTransformer.toString() + " apply union ... ");
        for (int j=0; j<ret.length; j++)
          TVLAAPITrace.tracePrintln(" index = " + ret[j] + " TVS = " + repository.getTVS(ret[j]).toString());
      }
    }
    
    return ret;
  }


  /********************************************************
   * Monitoring
   ********************************************************/
  
  public AnalysisStatus getStatus() {
    return interpreter.getStatus();
  }

}
