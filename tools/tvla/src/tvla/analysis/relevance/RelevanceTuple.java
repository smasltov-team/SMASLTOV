/*
 * Created on Sep 8, 2003
 */
package tvla.analysis.relevance;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import tvla.util.HashMapFactory;
import tvla.util.Logger;

/**
 * Records an assignment of relevant locations.
 * For example, given a property involving three types in the order (Connection,Statement,ResultSet), 
 * a tuple will contain an assignment of a relevant location for each type, e.g., (label_x, label_y, label_z).
 * @author Eran Yahav eyahav
 */
public class RelevanceTuple {

  /**
   * return a map from a projected tuple to a list of its source tuples. note
   * that the projection base (first item index) is zero !
   * 
   * @param tuples
   * @param from
   * @param to
   * @return
   */
  public static Map project(List tuples, int from, int to) {
    Map resultMap = HashMapFactory.make();

    for (Iterator it = tuples.iterator(); it.hasNext();) {
      List currTuple = (List) it.next();
      List currProjection = currTuple.subList(from, to);
      if (!resultMap.containsKey(currProjection))
        resultMap.put(currProjection, new ArrayList());

      ((List) resultMap.get(currProjection)).add(currTuple);
    }

    return resultMap;
  }

  /**
   * Recursively compute the cartesian product of a tuple list
   * 
   * @param tuples -
   *          list of value ranges lists
   * @return list of tuples generated by combniations from the value ranges
   */
  public static List cartesianProduct(List tuples) {
    List result = new ArrayList();
    if (tuples.isEmpty()) {
      result.add(new ArrayList());
      return result;
    } else {
      List firstList = (List) tuples.remove(0);
      for (Iterator vi = firstList.iterator(); vi.hasNext();) {
        Object val = vi.next();
        result.addAll(appendFirst(val, cartesianProduct(new ArrayList(tuples))));
      }
      return result;
    }
  }

  /**
   * Append value to head of each of the lists in the list
   * @param val new object to be added
   * @param tuples a list of tuples (each tuple itself represented as a list)
   * @return a list of tuples (each represented as a list) in which val was added as 
   * the first element of each tuple (list).
   */
  protected static List appendFirst(Object val, List tuples) {
    if (tuples.isEmpty())
      Logger.println("tuples is empty!");
    for (Iterator it = tuples.iterator(); it.hasNext();) {
      List currList = (List) it.next();
      currList.add(0, val);
    }
    return tuples;
  }

}
