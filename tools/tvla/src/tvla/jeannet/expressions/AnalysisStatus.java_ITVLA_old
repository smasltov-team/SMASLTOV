package tvla.jeannet.expressions;

import tvla.core.*; // Used for calling TVSFactory.collectStatisticsInfo
import tvla.util.*; // For the Timer class
import tvla.jeannet.util.AddUnderline; // added by Jason Breck 2014-04

/** This class represents the status of an analysis.
 * The status is comprised of statistical information and general mode
 * information which controls the behavior of the analysis
 * (for example, how verbose it should be).
 * The status also provides some measures for analyses to be responsive by
 * receiving input from the user.
 * Currently, the only input that's handled is when a user pushes the enter
 * button, which causes the analysis to (gracefully) finish.
 *
 * @author Roman Manevich.
 * @since 6.4.2002 Initial creation.
 */
public class AnalysisStatus {
	/** The id of the timer that measures the time needed to load the specification.
	 */
	public static final int LOAD_TIME			= 0;

	/** The id of the timer that measures the total analysis time.
	 */
	public static final int TOTAL_ANALYSIS_TIME = 1;

	/** The id of the timer that measures the time spent updating structures.
	 */
	public static final int UPDATE_TIME			= 2;

	/** The id of the timer that measures the time spent evaluating precontitions.
	 */
	public static final int PRECONDITION_TIME	= 3;

	/** The id of the timer that measures the time spent blurring structures.
	 */
	public static final int BLUR_TIME			= 4;

	/** The id of the timer that measures the time spent focusing structures.
	 */
	public static final int FOCUS_TIME			= 5;

	/** The id of the timer that measures the time spent coercing structures.
	 */
	public static final int COERCE_TIME			= 6;

	/** The id of the timer that measures the time spent merging structures to sets.
	 */
	public static final int JOIN_TIME			= 7;

        /** The id of the timer that measures the time spent meeting structures to sets.
        */
        public static final int MEET_TIME = 8;

    /** The id of the timer that measures the time spent in applying the meet
     *  in pair inner procedure while meeting structures ot sets.
     */
    public static final int MEET_PAIR_TIME     = 9;

    /** The id of the timer that measures the time spent in checking unary properties
     *  agreement and forming the matching graph while meeting structures to sets.
     */
    public static final int MEET_UNARY1_TIME     = 10;
    public static final int MEET_UNARY2_TIME     = 11;
    public static final int MEET_UNARY3_TIME     = 12;
    public static final int MEET_UNARY4_TIME     = 13;
    public static final int MEET_UNARY41_TIME     = 14;
    public static final int MEET_UNARY42_TIME     = 15;
    public static final int MEET_UNARY43_TIME     = 16;
    public static final int MEET_UNARY5_TIME     = 17;

    /** The id of the timer that measures the time spent in matching graph procedure
     *  while meeting structures to sets.
     */
    public static final int MEET_MATCH_TIME     = 18;

    /** The id of the timer that measures the time spent in verifying returned
     *  matching results and constructing actual meet.
     */
    public static final int MEET_VERIFY_TIME     = 19;

	/** The global load timer.
	 */
	public static Timer loadTimer = new Timer();

	/** Specifies whether runtime printouts should be printed to the console.
	 */
	public static boolean terse = ProgramProperties.getBooleanProperty("tvla.terse", false);

	/** Specifies whether warnings should be emitted.
	 */
	public static boolean emitWarnings;

	/** Specifies whether debug information should be emitted.
	 */
	public static boolean debug;

	/** Specifies whether each computation step should be outputted
	 */
	public static boolean debugstep;

	/** The number of structures generated by the analysis.
	 */
	public int numberOfStructures;

	/** The number of messagees generated by the analysis.
	 */
	public int numberOfMessages;

	/** The amount of memory used just before the analysis started.
	 */
	public long initialMemory;

	/** Garbage-collection frequency (every k structures)
	 */
	protected int gcEvery;

	/** Statistics printout frequency (every k structures)
	 */
	protected int statisticsEvery;

	/** The rate at which intermediate results should be dumped (every k structures).
	 */
	protected int dumpEvery;

	protected boolean continuousStatisticsReports;

	/** The maximum amount of memory used during analysis.
	 */
	protected long maxMemory;

	/** The average amount of memory used during analysis.
	 */
	protected long averageMemory;

	/** The number of times memory was measured during analysis.
	 */
	protected long memorySamples;

	protected int structuresPerSecond;
	protected double loadTime;
	protected double totalAnalysisTIme;
	protected double updateTime;
	protected double preconditionTime;
	protected double blurTime;
	protected double focusTime;
	protected double coerceTime;
	protected double joinTime;
    protected double meetTime;
    protected double meetPairTime;
    protected double meetUnary1Time;
    protected double meetUnary2Time;
    protected double meetUnary3Time;
    protected double meetUnary4Time;
    protected double meetUnary41Time;
    protected double meetUnary42Time;
    protected double meetUnary43Time;
    protected double meetUnary5Time;
    protected double meetMatchTime;
    protected double meetVerifyTime;
	
	/** An array of timres.
	 */
	protected Timer [] timers = new Timer[20];
	
	/** When true, indicates that the analysis should gracefully finish, i.e.,
	 * act as though the fixed-point has been reached.
	 */
	protected boolean finishAnalysis = false;

	/** The limit for the number of structures generated by the analysis.
	 */
	protected int structuresLimit;

	/** The limit for the number of messages generated by the analysis.
	 */
	protected int messagesLimit;


    /** Meet redundancy estimates.
     */
    protected int   m_meetRedValidNum       = 0;
    protected float m_meetRedValidRatioSum  = 0;
    protected float m_meetRedValidRatioAve  = 0;
    protected int   m_meetRedValidRedundant = 0;
    protected int   m_meetRedValidTotal     = 0;
    protected float m_meetRedValidRatio     = 0;

    protected int   m_meetRedRecurNum       = 0;
    protected float m_meetRedRecurRatioSum  = 0;
    protected float m_meetRedRecurRatioAve  = 0;
    protected int   m_meetRedRecurRedundant = 0;
    protected int   m_meetRedRecurTotal     = 0;
    protected float m_meetRedRecurRatio     = 0;
	
	/** Stores the last AnalysisStatus object that was constructued.
	 */
	private static AnalysisStatus activeStatus;

	/** Constructs an AnalysisStatus object and runs it in a new thread.
	 */
	public AnalysisStatus() {
		debug = ProgramProperties.getBooleanProperty("tvla.debug", false);
		debugstep = ProgramProperties.getBooleanProperty("tvla.debugstep", false);
		emitWarnings = ProgramProperties.getBooleanProperty("tvla.emitWarnings", true);
		structuresLimit = ProgramProperties.getIntProperty("tvla.engine.maxStructures", -1);
		messagesLimit = ProgramProperties.getIntProperty("tvla.engine.maxMessages", -1);
		dumpEvery = ProgramProperties.getIntProperty("tvla.engine.dumpEvery", -1);
		gcEvery = ProgramProperties.getIntProperty("tvla.engine.gcEvery", gcEvery);
		statisticsEvery = ProgramProperties.getIntProperty("tvla.engine.statisticsEvery", 1000);
		continuousStatisticsReports = ProgramProperties.getBooleanProperty("tvla.log.continuousStatisticsReports", false);

		initTimers();
		activeStatus = this;
	}

	/** Returns a globaly stored object of the last AnalysisStatus
	 * object that was created.
	 */
	public static AnalysisStatus getActiveStatus() {
		if (activeStatus == null)
			activeStatus = new AnalysisStatus();
		return activeStatus;
	}

	/** Checks whether there's a reason to (prematurely) finish the
	 * analysis.
	 * The reason could be that the user specified a number of structures
	 * limit or a number of messages limit and the limit was reached.
	 * Another reason is when a user explicitly asks for the analysis
	 * to finish (by pressing the keyboard and answering the dialog).
	 */
	public boolean shouldFinishAnalysis() {
		finishAnalysis |= (structuresLimit >= 0 && numberOfStructures > structuresLimit);
		finishAnalysis |= (messagesLimit >=0 && numberOfMessages > messagesLimit);
		return finishAnalysis;
	}

	/** Signals for the analysis to finish.
	 */
	public void finishAnalysis() {
		finishAnalysis = true;
	}

	/** Updates statistics information.
	 */
	public void updateStatus() {
		if (memorySamples == 0) {
			exhaustiveGC();
			initialMemory = Runtime.getRuntime().totalMemory() -
							Runtime.getRuntime().freeMemory();
		}

		long currentProfileMemory = Runtime.getRuntime().totalMemory() -
									Runtime.getRuntime().freeMemory();
		maxMemory = java.lang.Math.max(currentProfileMemory, maxMemory);
		++memorySamples;
		averageMemory += currentProfileMemory;
		TVSFactory.getInstance().collectStatisticsInfo();
	}

	/** Starts one of the status timers.
	 * @param timerId The id of the timer.
	 */
	public void startTimer(int timerId) {
		timers[timerId].start();
	}

	/** Stops one of the status timers.
	 * @param timerId The id of the timer.
	 */
	public void stopTimer(int timerId, boolean correct) {
		//timers[timerId].stop(correct);
		timers[timerId].stop(); // Changed by Jason Breck to match the tvla3 Timer() class.
		
		if (timerId == TOTAL_ANALYSIS_TIME) {
			// update the structurePerSecond figure
			structuresPerSecond = numberOfStructures;
			double totalTime = getTimerMeasure(TOTAL_ANALYSIS_TIME);
			structuresPerSecond = (int) ((double)numberOfStructures / totalTime);

			exhaustiveGC();

			// update time figures
			totalAnalysisTIme	= getTimerMeasure(TOTAL_ANALYSIS_TIME);
			updateTime			= getTimerMeasure(UPDATE_TIME);
			preconditionTime	= getTimerMeasure(PRECONDITION_TIME);
			blurTime			= getTimerMeasure(BLUR_TIME);
			focusTime			= getTimerMeasure(FOCUS_TIME);
			coerceTime			= getTimerMeasure(COERCE_TIME);
			joinTime			= getTimerMeasure(JOIN_TIME);
            meetTime            = getTimerMeasure(MEET_TIME);
            meetPairTime        = getTimerMeasure(MEET_PAIR_TIME);
            meetUnary1Time      = getTimerMeasure(MEET_UNARY1_TIME);
            meetUnary2Time      = getTimerMeasure(MEET_UNARY2_TIME);
            meetUnary3Time      = getTimerMeasure(MEET_UNARY3_TIME);
            meetUnary4Time      = getTimerMeasure(MEET_UNARY4_TIME);
            meetUnary41Time      = getTimerMeasure(MEET_UNARY41_TIME);
            meetUnary42Time      = getTimerMeasure(MEET_UNARY42_TIME);
            meetUnary43Time      = getTimerMeasure(MEET_UNARY43_TIME);
            meetUnary5Time      = getTimerMeasure(MEET_UNARY5_TIME);
            meetMatchTime       = getTimerMeasure(MEET_MATCH_TIME);
            meetVerifyTime      = getTimerMeasure(MEET_VERIFY_TIME);
			loadTime			= getTimerMeasure(LOAD_TIME);
		}
	}

    public void stopTimer(int timerId) {
        stopTimer(timerId, true);
    }

	/** Prints statistics gathered during the analysis to the log stream.
	 * @author Roman Manevich.
	 * @since 21.7.2001
	 */
	public void printStatistics() {
		double currentTotalTime = getTimerMeasure(TOTAL_ANALYSIS_TIME);
		double currentLoadTime = getTimerMeasure(LOAD_TIME);
		double currentFocusTime = getTimerMeasure(FOCUS_TIME);
		double currentPreconditionTime = getTimerMeasure(PRECONDITION_TIME);
		double currentUpdateTime = getTimerMeasure(UPDATE_TIME);
		double currentCoerceTime = getTimerMeasure(COERCE_TIME);
		double currentBlurTime = getTimerMeasure(BLUR_TIME);
		double currentJoinTime = getTimerMeasure(JOIN_TIME);
        double currentMeetTime = getTimerMeasure(MEET_TIME);
        double currentMeetPairTime = getTimerMeasure(MEET_PAIR_TIME);
        double currentMeetUnary1Time = getTimerMeasure(MEET_UNARY1_TIME);
        double currentMeetUnary2Time = getTimerMeasure(MEET_UNARY2_TIME);
        double currentMeetUnary3Time = getTimerMeasure(MEET_UNARY3_TIME);
        double currentMeetUnary4Time = getTimerMeasure(MEET_UNARY4_TIME);
        double currentMeetUnary41Time = getTimerMeasure(MEET_UNARY41_TIME);
        double currentMeetUnary42Time = getTimerMeasure(MEET_UNARY42_TIME);
        double currentMeetUnary43Time = getTimerMeasure(MEET_UNARY43_TIME);
        double currentMeetUnary5Time = getTimerMeasure(MEET_UNARY5_TIME);
        double currentMeetMatchTime = getTimerMeasure(MEET_MATCH_TIME);
        double currentMeetVerifyTime = getTimerMeasure(MEET_VERIFY_TIME);
		
		// Normalize times to reduce the effect of accumulating errors.
		double sumTimes = currentFocusTime +
						  currentPreconditionTime +
					      currentUpdateTime + 
		                  currentCoerceTime + 
		                  currentBlurTime + 
		                  currentJoinTime +
                          currentMeetTime;
		
		currentFocusTime = (currentFocusTime/sumTimes) * currentTotalTime;
		currentPreconditionTime = (currentPreconditionTime/sumTimes) * currentTotalTime;
		currentUpdateTime = (currentUpdateTime/sumTimes) * currentTotalTime;
		currentCoerceTime = (currentCoerceTime/sumTimes) * currentTotalTime;
		currentBlurTime = (currentBlurTime/sumTimes) * currentTotalTime;
		currentJoinTime = (currentJoinTime/sumTimes) * currentTotalTime;
		currentMeetTime = (currentMeetTime/sumTimes) * currentTotalTime;
		currentMeetPairTime = (currentMeetPairTime/sumTimes) * currentTotalTime;
		currentMeetUnary1Time = (currentMeetUnary1Time/sumTimes) * currentTotalTime;
		currentMeetUnary2Time = (currentMeetUnary2Time/sumTimes) * currentTotalTime;
		currentMeetUnary3Time = (currentMeetUnary3Time/sumTimes) * currentTotalTime;
		currentMeetUnary4Time = (currentMeetUnary4Time/sumTimes) * currentTotalTime;
		currentMeetUnary41Time = (currentMeetUnary41Time/sumTimes) * currentTotalTime;
		currentMeetUnary42Time = (currentMeetUnary42Time/sumTimes) * currentTotalTime;
		currentMeetUnary43Time = (currentMeetUnary43Time/sumTimes) * currentTotalTime;
		currentMeetUnary5Time = (currentMeetUnary5Time/sumTimes) * currentTotalTime;
		currentMeetMatchTime = (currentMeetMatchTime/sumTimes) * currentTotalTime;
		currentMeetVerifyTime = (currentMeetVerifyTime/sumTimes) * currentTotalTime;
		
		final double PERCISION = 100.0;
		currentLoadTime = ((int)(loadTime*PERCISION))/PERCISION;
		currentFocusTime = ((int)(focusTime*PERCISION))/PERCISION;
		currentPreconditionTime = ((int)(preconditionTime*PERCISION))/PERCISION;
		currentUpdateTime = ((int)(updateTime*PERCISION))/PERCISION;
		currentCoerceTime = ((int)(coerceTime*PERCISION))/PERCISION;
		currentBlurTime = ((int)(blurTime*PERCISION))/PERCISION;
		currentJoinTime = ((int)(joinTime*PERCISION))/PERCISION;
		currentMeetTime = ((int)(meetTime*PERCISION))/PERCISION;
		currentMeetPairTime = ((int)(meetPairTime*PERCISION))/PERCISION;
		currentMeetUnary1Time = ((int)(meetUnary1Time*PERCISION))/PERCISION;
		currentMeetUnary2Time = ((int)(meetUnary2Time*PERCISION))/PERCISION;
		currentMeetUnary3Time = ((int)(meetUnary3Time*PERCISION))/PERCISION;
		currentMeetUnary4Time = ((int)(meetUnary4Time*PERCISION))/PERCISION;
		currentMeetUnary41Time = ((int)(meetUnary41Time*PERCISION))/PERCISION;
		currentMeetUnary42Time = ((int)(meetUnary42Time*PERCISION))/PERCISION;
		currentMeetUnary43Time = ((int)(meetUnary43Time*PERCISION))/PERCISION;
		currentMeetUnary5Time = ((int)(meetUnary5Time*PERCISION))/PERCISION;
		currentMeetMatchTime = ((int)(meetMatchTime*PERCISION))/PERCISION;
		currentMeetVerifyTime = ((int)(meetVerifyTime*PERCISION))/PERCISION;

		memorySamples = memorySamples > 0 ? memorySamples : 1;

		if (terse)
			Logger.println( AddUnderline.add("Statistics") );
		Logger.println("Initial memory             : " + initialMemory/(float)1000000 + "\tMb");
		Logger.println("Max memory                 : " + maxMemory/(float)1000000 + "\tMb");
		Logger.println("Average memory             : " + (averageMemory/memorySamples)/(float)1000000 + "\tMb");
		Logger.println("Load time                  : " + (float) currentLoadTime + "\tseconds");
		Logger.println("Total analysis time        : " + (float) currentTotalTime + "\tseconds");
		Logger.println("Focus time                 : " + (float) currentFocusTime + "\tseconds");
		Logger.println("Precondition time          : " + (float) currentPreconditionTime + "\tseconds");
		Logger.println("Update time                : " + (float) currentUpdateTime + "\tseconds");
		Logger.println("Coerce time                : " + (float) currentCoerceTime + "\tseconds");
		Logger.println("Blur time                  : " + (float) currentBlurTime + "\tseconds");
		Logger.println("Join time                  : " + (float) currentJoinTime + "\tseconds");
		Logger.println("Meet time                  : " + (float) currentMeetTime + "\tseconds");
        if (currentMeetPairTime > 0)
            Logger.println(" total pair-meet time      : " + (float) currentMeetPairTime + "\tseconds");
        if (currentMeetUnary1Time > 0)
            Logger.println(" unary checking time #1    : " + (float) currentMeetUnary1Time + "\tseconds");
        if (currentMeetUnary2Time > 0)
            Logger.println(" unary checking time #2    : " + (float) currentMeetUnary2Time + "\tseconds");
        if (currentMeetUnary3Time > 0)
            Logger.println(" unary checking time #3    : " + (float) currentMeetUnary3Time + "\tseconds");
        if (currentMeetUnary4Time > 0)
            Logger.println(" unary checking time #4    : " + (float) currentMeetUnary4Time + "\tseconds");
        if (currentMeetUnary41Time > 0)
            Logger.println(" unary checking time #41   : " + (float) currentMeetUnary41Time + "\tseconds");
        if (currentMeetUnary42Time > 0)
            Logger.println(" unary checking time #42   : " + (float) currentMeetUnary42Time + "\tseconds");
        if (currentMeetUnary43Time > 0)
            Logger.println(" unary checking time #43   : " + (float) currentMeetUnary43Time + "\tseconds");
        if (currentMeetUnary5Time > 0)
            Logger.println(" unary checking time #5    : " + (float) currentMeetUnary5Time + "\tseconds");
        if (currentMeetMatchTime > 0)
            Logger.println(" matching time             : " + (float) currentMeetMatchTime + "\tseconds");
        if (currentMeetVerifyTime > 0)
            Logger.println(" result verification time  : " + (float) currentMeetVerifyTime + "\tseconds");
        Logger.println(" match redun/total ratio   : " + 
                m_meetRedValidRedundant + "/" + m_meetRedValidTotal + " " +
                m_meetRedValidRatio + " (" + m_meetRedValidRatioAve + ")");
        Logger.println(" recur redun/total ratio   : " + 
                m_meetRedRecurRedundant + "/" + m_meetRedRecurTotal + " " +
                m_meetRedRecurRatio + " (" + m_meetRedRecurRatioAve + ")");

		Logger.println("Total number of structures : " + numberOfStructures);
		Logger.println("Structures per second      : " + structuresPerSecond);
		Logger.println("Total number of messages   : " + numberOfMessages);
	}
	
	/** Returns the time measured by the specified timer.
	 * @param timerId The id of the timer.
	 */
	public double getTimerMeasure(int timerId) {
		return timers[timerId].total() / 1000.0;
	}

	/** Does exhaustive garbage-collection until there is no
	 * change in the amount of free memory.
	 */
	public static void exhaustiveGC() {
	    /*
	    Logger.println("exhaustiveGC");
		long free1 = 0;
		long free2 = Runtime.getRuntime().freeMemory();
		while (free1 < free2) {
			free1 = free2;
			System.gc();
			free2 = Runtime.getRuntime().freeMemory();
		}
	    */
	}

	/** Initializes the timers array and stores the load timer
	 * at the first position.
	 */
	protected void initTimers() {
		timers[0] = loadTimer; // reference the static timer
		for (int i = 1; i < timers.length; ++i)
			timers[i] = new Timer();
	}


    /** Update Meet redundancy estimation -- matching validity ratio.
     */
    public void meetRedValidUpdate(int redundant, int total) {
        /* Update average redundancy ratio. */
        float meetRedValidCurrRatio =
            (total == 0 ? 0 : (float) redundant / (float) total);
        m_meetRedValidNum++;
        m_meetRedValidRatioSum += meetRedValidCurrRatio;
        m_meetRedValidRatioAve = m_meetRedValidRatioSum / (float) m_meetRedValidNum;

        /* Update overall redundancy ratio. */
        m_meetRedValidRedundant += redundant;
        m_meetRedValidTotal     += total;
        m_meetRedValidRatio =
            (m_meetRedValidTotal == 0 ?
             0 : (float) m_meetRedValidRedundant / (float) m_meetRedValidTotal);
    }

    public void meetRedRecurUpdate(int redundant, int total) {
        /* Update average redundancy ratio. */
        float meetRedRecurCurrRatio =
            (total == 0 ? 0 : (float) redundant / (float) total);
        m_meetRedRecurNum++;
        m_meetRedRecurRatioSum += meetRedRecurCurrRatio;
        m_meetRedRecurRatioAve = m_meetRedRecurRatioSum / (float) m_meetRedRecurNum;

        /* Update overall redundancy ratio. */
        m_meetRedRecurRedundant += redundant;
        m_meetRedRecurTotal     += total;
        m_meetRedRecurRatio =
            (m_meetRedRecurTotal == 0 ?
             0 : (float) m_meetRedRecurRedundant / (float) m_meetRedRecurTotal);
    }
}
